<!doctype html><html lang=en dir=" auto">
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta charset=utf-8>
<meta name=Share-Source-Verification content="https://blog.zhangyingwei.com/">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=renderer content="webkit">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta property="og:title" content="Posts">
<meta property="og:image" content="/images/favicon64.ico">
<meta name=msvalidate.01 content="1B50C3A24BF817BB86D82C8429075AE4">
<meta name=bytedance-verification-code content="rjX6knbDoNxpR4Asxe2M">
<meta name=robots content="index, follow">
<title>Posts | 胡说</title>
<meta name=keywords content>
<meta name=description content="Posts - 胡说">
<meta name=author content="zhangyw">
<link rel=canonical href=https://blog.zhangyingwei.com/posts/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.aaa22db3cdacc948a29b96b6ee3741f2327c102d2eb99e63e7d362aeeec4718f.css integrity="sha256-qqIts82syUiim5a27jdB8jJ8EC0uuZ5j59Niru7EcY8=" rel="preload stylesheet" as=style>
<link rel=icon href=https://blog.zhangyingwei.com/images/favicon64.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.zhangyingwei.com/images/favicon16.ico>
<link rel=icon type=image/png sizes=32x32 href=https://blog.zhangyingwei.com/images/favicon32.ico>
<link rel=apple-touch-icon href=https://blog.zhangyingwei.com/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.zhangyingwei.com/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<link rel=alternate type=application/rss+xml href=https://blog.zhangyingwei.com/posts/index.xml>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link href=https://hushuo.zhangyingwei.com/NotoSerifSC.css rel=stylesheet>
<link href=https://hushuo.zhangyingwei.com/JetBrainsMono.css rel=stylesheet>
<script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?ba380df4e327c711daf3b841b4089ce4",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script>
<script async src=https://umami.zhangyingwei.com/script.js data-website-id=cb41ccbd-6ee9-4587-9c03-d872f2d10472></script><meta property="og:title" content="Posts">
<meta property="og:description" content="胡说，一个寂寞的、即将被时代潮流冲刷在沙滩上的 IT 从业者的自言自语">
<meta property="og:type" content="website">
<meta property="og:url" content="https://blog.zhangyingwei.com/posts/"><meta property="og:site_name" content="胡说">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.zhangyingwei.com/posts/"}]}</script>
</head>
<body class="font-activate bg-color mt-20 list" id="
    top">
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class="header font-activate sticky-element shadow-b">
<nav class=nav>
<div class=logo>
<a href=https://blog.zhangyingwei.com/ accesskey=h title="胡说 (Alt + H)">胡说</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.zhangyingwei.com/series/ title=系列文章>
<span>系列文章</span>
</a>
</li>
<li>
<a href=https://blog.zhangyingwei.com/archives/ title=归档>
<span>归档</span>
</a>
</li>
<li>
<a href=https://blog.zhangyingwei.com/tags/ title=标签>
<span>标签</span>
</a>
</li>
</ul>
</nav>
</header><div style=height:20px></div>
<main class="main font-activate bg-color">
<header class=page-header>
<h1>Posts ✨</h1>
</header>
<div class="article-item-wrapper fg-color">
<article class="post-entry item-padding">
<div class=post-date>
📅 April 12, 2024
</div>
<header class=entry-header>
<h2>数据处理中的责任链模式
</h2>
</header>
<section class=entry-content>
<p>在我的工作中，数据处理占据了比较大的权重。在数据处理的过程中，有一项比较繁琐的工作，就是对日志中的每个字段进行单独校验和处理，校验的内容分别有一下几类：
字段数量校验 字段为空判断 字段内容校验 特殊字段校验、信息补充 增加标签字段 在这类场景中，最常规的方法就是编写冗长的 if-else 代码段进行按部就班的校验，这显然不是最佳方案。
责任链模式可以有效地解决上述繁琐的工作。通过将不同的校验和处理逻辑分配给不同的处理者，形成一条责任链，数据依次通过各个处理者进行处理。这样做的好处是：
避免编写大量的重复 if-else 代码 将每个校验逻辑进行隔离，区分责任边界 逻辑清晰，代码简洁 以下是一个简单的责任链模式代码示例：
public class ChainHandler { private List&lt;Handler> handlers; public ChainHandler() { this.handlers = new ArrayList&lt;>(); } public void addHandler(Handler handler) { handlers.add(handler); } public boolean handle(LogEntry logEntry) { for (Handler handler : handlers) { handler.handle(logEntry); if (!handler.isComplete()) { return false; // 如果处理程序未完成，则整个处理链失败 } } return true; // 如果所有处理程序均完成，则整个处理链成功 } } // 定义责任链接口 public interface Handler { boolean isComplete(); void handle(LogEntry logEntry); } // 字段数量校验 public class FieldCountHandler implements Handler { @Override public boolean isComplete() { // 检查字段数量是否满足要求 return true; } @Override public void handle(LogEntry logEntry) { // 进行字段数量的校验和处理 } } 在上述代码中，ChainHandler 类管理责任链中的处理者。FieldCountHandler 和 FieldContentHandler 分别是处理字段数量和字段内容的处理者实现。...</p>
</section>
<a class=entry-link aria-label="post link to 数据处理中的责任链模式" href=https://blog.zhangyingwei.com/posts/2024m4d12h14m25s41/ name=数据处理中的责任链模式>
<span style=display:inline-block;width:0;height:0;opacity:0>数据处理中的责任链模式</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 February 2, 2024
</div>
<header class=entry-header>
<h2>SpringBoot 中实现订单过期自动取消
</h2>
</header>
<section class=entry-content>
<p>在电商等需要在线支付的应用中，通常需要设置订单自动取消的功能。本文将介绍几种在 Spring Boot 中实现订单 30 分钟自动取消的方案，包括定时任务、延迟队列和 Redis 过期事件。
方案一：定时任务 定时任务是一种简单且常用的实现订单自动取消的方案。在 Spring Boot 中，可以使用注解@Scheduled来定义定时任务，任务会按照指定的时间间隔执行。在这个方案中，我们可以定义一个定时任务，每隔 30 分钟检查一次未支付的订单，如果订单生成时间超过 30 分钟，则自动取消该订单。
代码示例：
import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; @EnableScheduling @Component public class OrderCancelSchedule { @Autowired private OrderService orderService; @Scheduled(cron = "0 0/1 * * *?") public void cancelUnpaidOrders() { List&lt;Order> unpaidOrders = orderService.getUnpaidOrders(); unpaidOrders.forEach(order -> { if (order.getCreationTime().plusMinutes(30).isBefore(LocalDateTime.now())) { orderService.cancelOrder(order.getId()); } }); } } 在上面的代码中，我们定义了一个名为OrderCancelSchedule的组件，并使用@EnableScheduling注解启用定时任务功能。在组件中，我们定义了一个名为cancelUnpaidOrders的方法，并使用@Scheduled注解来指定该方法作为定时任务执行。cron表达式"0 0/1 * * *?"表示任务每隔 1 分钟执行一次。
方案二：延迟队列 延迟队列是一种将任务延迟执行的机制，入队的元素在一定的延迟时间之后才能出队。在这个方案中，我们可以将订单的 ID 放入延迟队列中，并设置延迟时间为 30 分钟。当延迟时间到期时，从队列中取出订单 ID，并执行取消订单的操作。...</p>
</section>
<a class=entry-link aria-label="post link to SpringBoot 中实现订单过期自动取消" href=https://blog.zhangyingwei.com/posts/2024m4d2h10m4s42/ name="SpringBoot 中实现订单过期自动取消">
<span style=display:inline-block;width:0;height:0;opacity:0>SpringBoot 中实现订单过期自动取消</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 January 30, 2024
</div>
<header class=entry-header>
<h2>把 Obsidian 变为 Hugo 博客的集成管理平台
</h2>
</header>
<section class=entry-content>
<p>今天早上无聊闲逛，看到有不少人是从我的 Obsidian + Hugo 系列，开始了解原来 Obsidian 和 Hugo 还可以这么搭配的。
但是不少人反馈，根据 Hugo 博客写作最佳实践 和 Obsidian + Hugo 最佳配置推荐 这两篇文章操作起来感觉确实方便了，但是方便的不多。整个流程没有非常流畅。甚至感觉有些流程设计的过于繁琐。
不否认，确实是这种感觉，问题在我。
实际上这是我设计的一整套流程，但这两篇博客只讲了关键的一部分，还有一些细枝末节没有讲出来。
所以我临时决定再增加一篇文章说明，把整套流程讲清楚。担心表达能力欠佳，我还录了视频辅助大家理解。
中心思想 整个流程设计的中心思想就是：解决繁琐的操作流程，把操作自动化+高度集中，解放思想，精力都用在写作上。
管理面板 在 Obsidian 的诸多插件的加持下，最终实现所有管理功能集成在一个管理中心，效果如下：
上图中的内容共分为几部分：
统计图，这里只根据发布情况做了发布占比统计，大家完全可以根据自己的需求设计更美观实用的统计图表 操作按钮+笔记：共集成了三个操作按钮，点击新建博客按钮可以根据模板自动创建一篇空白文章；点击发布博客按钮可以把博客内容自动推送到 github，从而触发 github action 自动部署流程；点击获取更新按钮可以从github上同步最新的仓库内容。 草稿箱：使用 dataview 插件，把草稿内容列举出来，归集为草稿箱，直接点击对应草稿便可以开始编辑内容 已发布：把所有已经发布的内容列举出来，方便查看 视频演示 以下视频演示了整个 新建 -> 写作 -> 发布 流程，一刀未剪
技术细节 接下来说一下技术细节。说实话，这里其实并没有太多技术细节，只是一层窗户纸罢了，只要一捅破，大家瞬间就明白了，看到这里应该有很多人已经可以明白实现原理了。
基于 Hugo 博客写作最佳实践 这篇文章，我们可以通过 QuickAdd 插件实现各种自动化命令，在此基础上，只需要增加一个 Buttons 插件，便可以把命令通过点击按钮的方式进行调用。
Buttons 插件安装完成之后，在首页添加如下代码：
新建博客按钮代码 发布博客按钮代码 获取更新按钮代码 总结 以上就是全部内容了，没有什么高深的技术内容，都是一些插件运用的技巧。 有了这个管理面板之后，你是不是可以把精力全部放在写作上了呢？...</p>
</section>
<a class=entry-link aria-label="post link to 把 Obsidian 变为 Hugo 博客的集成管理平台" href=https://blog.zhangyingwei.com/posts/2024m1d30h10m7s52/ name="把 Obsidian 变为 Hugo 博客的集成管理平台">
<span style=display:inline-block;width:0;height:0;opacity:0>把 Obsidian 变为 Hugo 博客的集成管理平台</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 January 25, 2024
</div>
<header class=entry-header>
<h2>如果我们想实现一个 WAF之 -- 什么是 WAF
</h2>
</header>
<section class=entry-content>
<p>如果我们想实现一个简易的 WAF，我们实际上需要干什么？我们需要先了解什么是 WAF。
🐭 什么是 WAF WAF 全称 Web Application Firewall，是一种工作在应用层（7 层）的防火墙，主要用于对应用层中的 HTTP 流量进行监测、过滤和阻止。主要适用于 Web 应用中存在的已知的安全漏洞，例如：SQL 注入、CSRF 跨站请求伪造攻击、XSS 跨站脚本攻击等。
其主要防护原理是基于规则匹配，通过预制的识别规则，对 HTTP 协议中提取出来的信息进行匹配，如果可以匹配，则该请求被认为是攻击行为。WAF 将会对其执行相关的操作（告警、阻断、记录日志）。
综上所诉，WAF 的基本原理如下：
那么回到问题，什么是 WAF 呢？
WAF 是一个工作在应用层，主要针对 HTTP 流量进行解析、检测的装置；其检测功能主要基于规则引擎，通过预制规则，对流量中的相关信息进行匹配，能够针对流量中的 SQL 注入、CSRF、XSS 等 Web 攻击行为进行识别与防护，防护手段主要有告警、阻断、记录日志。
🐮 WAF 通常部署在哪里 从形态上来讲， WAF 主要分为软件型 WAF 和硬件型 WAF
软件型 WAF 主要以嵌入的形式进行部署，一般部署在 Web 服务器中，常见的例如 nginx waf、apache waf、openresty waf 等。
硬件型 WAF 主要通过软件绑定硬件的方式，其部署方式多种多样，以下内容中的 WAF 默认指代硬件 WAF。
WAF 的部署模式通常有： 反向代理、透明代理、透明桥、流量镜像等方式。
反向代理 客户与 WAF 进行交互，WAF 将客户的请求直接转发至后端，后方的 Web Server 与 WAF 进行交互，不会直接暴漏给客户。...</p>
</section>
<a class=entry-link aria-label="post link to 如果我们想实现一个 WAF之 -- 什么是 WAF" href=https://blog.zhangyingwei.com/posts/2024m1d25h13m45s53/ name="如果我们想实现一个 WAF之 -- 什么是 WAF">
<span style=display:inline-block;width:0;height:0;opacity:0>如果我们想实现一个 WAF之 -- 什么是 WAF</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 January 16, 2024
</div>
<header class=entry-header>
<h2>防止 SQL 注入：WAF 就足够了吗？
</h2>
</header>
<section class=entry-content>
<p>在目前的网络攻防环境中，SQL 注入仍然是一种应用广泛、操作简单、且效果显著的攻击手段。防范 SQL 注入攻击，对于防止数据泄露、保护用户隐私和保护 Web 应用的完整性任然是至关重要的一项工作。
Web 应用程序防火墙（WAF）系统，通常被认为是防御 SQL 注入攻击的主要基础设施。但有 WAF 真的就足够了吗？答案当然是否定的。
接下来，首先解释一下 WAF 如何防止 SQL 注入的，然后再展示它可能在什么情况下无法提供足够的保护能力。
WAF 如何防御 SQL 注入 简单来说，WAF 在 SQL 注入类防护中，主要通过监控应用层协议在网络流量中的潜在恶意签名、字符序列来达到防护效果。通过监控和过滤 HTTP GET 和 POST 请求，并解析传入的 SQL 代码片段，WAF 可以识别已知的有害 SQL 语法，并且对相应的恶意的数据包流量进行告警与阻止。
虽然 WAF 可以提供针对 SQL 注入攻击的安全检测和防护，但其有效性取决于它的识别规则。
什么情况下 WAF 会失效 在许多情况下，WAF 可能无法防止 SQL 注入：
未知的攻击模式和特征：WAF 擅长检测已知的攻击模式和特征，面对更复杂或未知的攻击方法则力有不逮。 封装技术：攻击者可以对载荷做针对性处理；使用嵌套编码，或者将恶意请求的部分放在 WAF 检查的字节之外；面对这种封装过后的载荷，WAF不具备识别能力。 配置错误：WAF的识别和防护功能，依赖防护规则的配置，如果规则配置错误，它可能无法提供足够防护能力来保护和抵御更复杂或不常见的 SQL 注入攻击。 更新和调整：随着 WEB 开发技术的更新迭代，有些更新可能会使之前的防护规则失效；如果 WAF 没有定期更新升级相应的规则，将无法提供相应的防护能力。 非网络流量数据：WAF 只能处理来自网络流量的问题，如果问题来自应用程序内部的代码或数据源而不经过网络力量，则 WAF 无法处理 0Day 漏洞：WAF 无法防止 0Day 漏洞利用 JSON 语法：WAF 可能无法识别 SQL 注入载荷中的恶意 JSON 语法内容，从而可以使用此类攻击者绕过 WAF 保护 示例 Claroty 研究人员能够通过在 SQL 注入攻击中使用 JSON 语法绕过 Amazon Web Services（AWS）内置的 WAF。通过将简单的 JSON 语法前置到 SQL 请求的开头，他们可以使用 SQLi 漏洞在云上泄露敏感信息。同样的 JSON in SQL 攻击也对 Cloudflare、F5、Imperva 和 Palo Alto Networks 的 WAF 有效 Reddit 用户对 WAF 测试了几个 SQL 注入负载，发现 WAF 基于某些关键字阻止了一些请求，同时仍然允许其他可疑查询。例如，/?...</p>
</section>
<a class=entry-link aria-label="post link to 防止 SQL 注入：WAF 就足够了吗？" href=https://blog.zhangyingwei.com/posts/2024m1d15h10m42s57/ name="防止 SQL 注入：WAF 就足够了吗？">
<span style=display:inline-block;width:0;height:0;opacity:0>防止 SQL 注入：WAF 就足够了吗？</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 January 15, 2024
</div>
<header class=entry-header>
<h2>盘点那些年我做过的东西
</h2>
</header>
<section class=entry-content>
<p>我是一个很容易焦虑的人，大部分焦虑都源自经济压力。
我也是一个很理想主义的人，始终妄想着能够做出一款为大家所认可的产品，随之产生睡后收入。
我还是一个很悲观的人，在做产品的过程中，随着不断的自我反思，会不断陷入：这个东西有人做了；这个东西不会有市场的；这个东西不是一个人能做出来的。等等类似的自我怀疑中。
这些年有不少想法，做了不少工作，但是都胎死腹中，分享出来供大家消遣。我的 Github 签名是 “废材程序员”，真是太贴切了。
treehole-jekyll (一个有点想法的博客系统) 一个包含完整前后端功能的博客系统，使用 Java 开发，采用 sqlite 作为数据库，兼容了 Jekyll 的主题。
部署在小水管云服务器中，后因为优化力度不够+Java对内存的优化确实不是很好，导致小水管只够跑一个博客服务。不能忍受资源浪费，遂放弃自建服务回到 Github Pages 的怀抱。省心省力省钱。
Solid (为博客开发的模板引擎) 在上诉博客系统开发过程中，为了兼容 Jekyll 模板引擎语法，开发的基于 Java 的模板引擎，可以嵌入到 Springboot 中作为视图渲染引擎进行使用。后一直闲置至今。 Hermes (基于 RSS 的文章聚合推荐平台) 有一段时间特别痴迷 RSS，而当时市面上的 RSS 阅读器并没有独角兽的出现，找来找去没找到合适的，所以就种下了 “我要开发一个的蛊”，后来来来回回做了好几个， hermes 算是整体完成度比较高的一个。具备完整的前端+后台+RSS爬虫+任务调度。
还做过一个叫 Miner 的应用，后来也不了了之了。
专注了吗小程序 前段时间逛论坛的时候，发现微信小程序个人认证的费用降到了 30 块，本着宁可不用不能没有的原则赶紧充值上车了。
又本着空着也是空着，总要放点什么的原则，做了这款专注了吗的小程序。主打任务专注管理。
AI 套壳工具 AI 突然就火了，套壳工具如雨后春笋般冒出来，做肯定要做一个的，但是由于聊天回应特别慢，接口延迟的问题一直没法解决，所以一直也没进行推广。想用的可以联系我在后台免费加套餐。花钱暂时就免了吧。
cockroach2 (开源 java 爬虫框架) 有一段时间，对爬虫特别痴迷，而且正好那段时间在研究 Java 的对象管理，索性整合一下做了一个爬虫框架。主打用尽可能少的配置、写出一个灵活、健壮的爬虫。当时在第一个版本出来的时候还许下豪言，要做真正的分布式爬虫，而不仅仅是队列+爬虫；要集成分布式任务、分布式事务等等，后续由于工作繁忙也渐渐的都放下了。目前任然是一个小巧、灵活、健壮、可观测的爬虫框架。 ultraman-rpc (一个练手的RPC项目) 单纯练手项目，实现了基于接口的 RPC 调用。 fas-cloud （faas 平台） 云，是一个很迷人的概念。曾经我也立志在云上创出一片天。但是最终还是没有完成。
整体项目完成了 50% 左右，做了 Function 函数管理功能、Function模板管理功能、Function 执行以及动态管理功能，很遗憾没有做完，...</p>
</section>
<a class=entry-link aria-label="post link to 盘点那些年我做过的东西" href=https://blog.zhangyingwei.com/posts/2024m1d15h10m37s29/ name=盘点那些年我做过的东西>
<span style=display:inline-block;width:0;height:0;opacity:0>盘点那些年我做过的东西</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 January 3, 2024
</div>
<header class=entry-header>
<h2>专注了吗，一款因微信认证费降价而产生的产品
</h2>
</header>
<section class=entry-content>
<p>最近偶然在论坛看到有人说微信认证费用降价，由以前的 300 块降低至 30 块，于是赶紧去做了认证。
既然已经做了认证，那么名额空着视乎不太好，于是便产生了做一个产品出来挂着的念头。而说到产品，就不得不提研发人员三板斧，导航、记账和代办。
索性就在这里找个角度切入，从代办的角度切入，从另外的角度做了这款叫 《专注了吗》 的任务跟踪小程序。
目前小程序已经上架，主页是： https://miniapp.fascloud.org/
主要功能 小程序主要功能为记录任务的进展情况，例如：
学生党记录每一科的学习进度以及时间花费情况 上班党记录每一个工作的具体进展 宝妈记录宝宝的吃饭情况，拉屎 💩 情况 等等… 所有适用于分段完成的任务都可以用来记录。
界面 </p>
</section>
<a class=entry-link aria-label="post link to 专注了吗，一款因微信认证费降价而产生的产品" href=https://blog.zhangyingwei.com/posts/2024m1d3h13m25s53/ name=专注了吗，一款因微信认证费降价而产生的产品>
<span style=display:inline-block;width:0;height:0;opacity:0>专注了吗，一款因微信认证费降价而产生的产品</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 January 2, 2024
</div>
<header class=entry-header>
<h2>探索 Kafka 消息丢失的问题和解决方案
</h2>
</header>
<section class=entry-content>
<p>在构建基于 Kafka 的消息处理系统中，消息丢失是一个需要深入研究的重要问题。强大的系统不仅依赖于其功能，而且依赖于其可靠性。因此，理解消息丢失的原因，并采取必要的措施确保消息的一致性和完整性，是构建高效可靠消息系统的重要组成部分。本文将详细分析 Kafka 消息丢失的主要原因，并提供一系列策略来解决这个问题。
消息丢失的原因 生产者端问题： 在 Kafka 系统中，生产者负责发送消息。然而，由于网络故障或其他未知问题，生产者可能无法成功发送消息到 Kafka 服务器。 Kafka 服务端问题： Kafka 服务器可能会因为硬件故障、磁盘满或其他异常情况导致消息丢失。 消费者端问题： 消费者负责处理接收到的消息。但是，消费者在处理消息时可能会出现错误或崩溃，导致消息未被正确处理。 解决方案与措施 生产者端相关方案与措施 发送消息处理回调方法 由于消息的常规发送采用的异步方式，所以通常会忽略掉回调处理，为了保证消息的发送质量，一定需要对回调信息进行处理或者改为同步发送。
producer.send(new ProducerRecord&lt;>(topic, messageKey, messageStr), new CallBack({...}); 设置有效的重试策略以及 acks 配置 我们可以在生产者端设置一个有效的重试策略，保证消息成功发送。例如，我们可以使用指数退避算法进行重试。这种算法会在每次重试失败后等待更长的时间，从而减轻服务器的压力，并增加消息成功发送的概率。
通过设置 Producer acks 机制，我们可以确保生产者收到 Kafka 服务器的确认，知晓消息是否被成功提交。
acks=0： 生产者在发送消息后不会等待任何确认，直接将消息视为发送成功。这种设置下，可能会出现消息丢失的情况，因为生产者不会等待服务器的任何确认即认为消息发送成功。 acks=1： 生产者在发送消息后会等待 Leader Broker 的确认，确认后即视为消息发送成功。这种设置下，消息的可靠性得到一定程度的保证，但仍有可能发生 Leader Broker 宕机导致消息丢失的情况。 acks=all： 生产者在发送消息后会等待 Leader Broker 和所有副本的确认，确认后才视为消息发送成功。这种设置下，消息的可靠性和一致性得到最高级别的保证，但同时也会增加网络延迟和资源消耗。 import org.apache.kafka.clients.producer.*; import org.apache.kafka.common.serialization.StringSerializer; import java.util.Properties; public class KafkaProducerExample { private static final String TOPIC_NAME = "my-topic"; private static final String BOOTSTRAP_SERVERS = "localhost:9092"; public static void main(String[] args) { Properties props = new Properties(); props....</p>
</section>
<a class=entry-link aria-label="post link to 探索 Kafka 消息丢失的问题和解决方案" href=https://blog.zhangyingwei.com/posts/2024m4d2h10m23s15/ name="探索 Kafka 消息丢失的问题和解决方案">
<span style=display:inline-block;width:0;height:0;opacity:0>探索 Kafka 消息丢失的问题和解决方案</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 June 1, 2022
</div>
<header class=entry-header>
<h2>QuickDashboard 产品更新 [V0.0.9.0]
</h2>
</header>
<section class=entry-content>
<p>这个项目到目前为止没做过什么推广，只在 V 站和其他一两个常逛的论坛发了一下，因此也没有太多人知道。 Chrome 和 Edge 两个商店加起来大概有一百五十个左右的用户。所以很大程度还是属于一个自娱自乐的项目。
近期需要经常关注 B 站 几个账号的粉丝数量，因此设计并上线了一个监控看板的功能。
监控看板主要为了监控数字类的数据内容，比如上边提到的 B 站某个账号的粉丝等。
这个版本共包含了 4 个监控项。
B 站某个账号的粉丝数量 B 站某个账号的视频数量 Github 账号的 Follower 数量 Github 某个仓库的 Star 数量 效果图如下：
感兴趣的可以在 ChromeStore 或者 Edge Store 进行更新试用。
有问题可以直接在评论区反馈</p>
</section>
<a class=entry-link aria-label="post link to QuickDashboard 产品更新 [V0.0.9.0]" href=https://blog.zhangyingwei.com/posts/2022m5d24h15m23s26/ name="QuickDashboard 产品更新 [V0.0.9.0]">
<span style=display:inline-block;width:0;height:0;opacity:0>QuickDashboard 产品更新 [V0.0.9.0]</span>
</a>
</article>
<article class="post-entry item-padding">
<div class=post-date>
📅 May 16, 2022
</div>
<header class=entry-header>
<h2>QuickDashboard 产品介绍
</h2>
</header>
<section class=entry-content>
<p>我的新作品 QuickDashboard，是一款 Chrome 浏览器插件。得益于 Chromium 内核的成功，理论上只要是基于 Chromium 内核的浏览器都可以兼容。
下载地址： 七牛云 下载 Chrome 商店 下载 QuickDashboard 是一款新标签页插件，所谓新标签页插件就是插件安装之后会接管 Chrome 浏览器新建标签页行为，取代默认的空白标签页，打开插件作为浏览器的新标签页。
这个插件，一共提供了四个大的功能项。
以下所有说明均基于目前的最新版本 V0.8.0.0
1. 时钟 时钟模块提供了翻页时钟和点阵时钟两种展示方式
翻页时钟 点阵时钟 时钟的颜色可以自定义，详细操作见设置说明
2. 书签管理 书签管理功能主要基于 Chrome 的书签管理接口，作为 Chrome 书签的增强功能。在 Chrome 自身书签的基础上进行扩展。
为书签增加了界面 扩展了标签功能，支持为每个书签增加标签，方便分类，每个书签最多可以设置 5 个标签 增加搜索功能，支持模糊搜索；可以通过书签名、书签目录名以及标签名进行搜索 3. 导航页 导航页是一个高频使用的功能， QuickDashboard 提供的导航页具备了目前市面上绝大多数导航页具备的功能：
快捷搜索功能，提供搜索框，可以快速搜索 可以自定义添加导航网址 导航网址支持分类 在此基础上，还额外创新提供了根据设置进行差异化导航的功能。...</p>
</section>
<a class=entry-link aria-label="post link to QuickDashboard 产品介绍" href=https://blog.zhangyingwei.com/posts/2022m5d16h20m22s20/ name="QuickDashboard 产品介绍">
<span style=display:inline-block;width:0;height:0;opacity:0>QuickDashboard 产品介绍</span>
</a>
</article>
</div>
<footer class=page-footer>
<nav class=pagination>
<a class=next href=https://blog.zhangyingwei.com/posts/page/2/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2024 <a href=https://blog.zhangyingwei.com/>胡说</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
<span>
订阅
<a href=/index.xml rel=noopener target=_blank>RSS</a>
</span>
</footer>
<a href=# aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script></script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body>
</html>