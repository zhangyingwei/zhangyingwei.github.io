<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 胡说</title>
    <link>https://blog.zhangyingwei.com/posts/</link>
    <description>Recent content in Posts on 胡说</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-ch</language>
    <lastBuildDate>Fri, 02 Feb 2024 10:04:42 +0800</lastBuildDate><atom:link href="https://blog.zhangyingwei.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SpringBoot 中实现订单过期自动取消</title>
      <link>https://blog.zhangyingwei.com/posts/2024m4d2h10m4s42/</link>
      <pubDate>Fri, 02 Feb 2024 10:04:42 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2024m4d2h10m4s42/</guid>
      <description>在电商等需要在线支付的应用中，通常需要设置订单自动取消的功能。本文将介绍几种在 Spring Boot 中实现订单 30 分钟自动取消的方案，包括定时任务、延迟队列和 Redis 过期事件。
方案一：定时任务 定时任务是一种简单且常用的实现订单自动取消的方案。在 Spring Boot 中，可以使用注解@Scheduled来定义定时任务，任务会按照指定的时间间隔执行。在这个方案中，我们可以定义一个定时任务，每隔 30 分钟检查一次未支付的订单，如果订单生成时间超过 30 分钟，则自动取消该订单。
代码示例：
import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; @EnableScheduling @Component public class OrderCancelSchedule { @Autowired private OrderService orderService; @Scheduled(cron = &amp;#34;0 0/1 * * *?&amp;#34;) public void cancelUnpaidOrders() { List&amp;lt;Order&amp;gt; unpaidOrders = orderService.getUnpaidOrders(); unpaidOrders.forEach(order -&amp;gt; { if (order.getCreationTime().plusMinutes(30).isBefore(LocalDateTime.now())) { orderService.cancelOrder(order.getId()); } }); } } 在上面的代码中，我们定义了一个名为OrderCancelSchedule的组件，并使用@EnableScheduling注解启用定时任务功能。在组件中，我们定义了一个名为cancelUnpaidOrders的方法，并使用@Scheduled注解来指定该方法作为定时任务执行。cron表达式&amp;quot;0 0/1 * * *?&amp;quot;表示任务每隔 1 分钟执行一次。
方案二：延迟队列 延迟队列是一种将任务延迟执行的机制，入队的元素在一定的延迟时间之后才能出队。在这个方案中，我们可以将订单的 ID 放入延迟队列中，并设置延迟时间为 30 分钟。当延迟时间到期时，从队列中取出订单 ID，并执行取消订单的操作。</description>
    </item>
    
    <item>
      <title>把 Obsidian 变为 Hugo 博客的集成管理平台</title>
      <link>https://blog.zhangyingwei.com/posts/2024m1d30h10m7s52/</link>
      <pubDate>Tue, 30 Jan 2024 10:07:52 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2024m1d30h10m7s52/</guid>
      <description>今天早上无聊闲逛，看到有不少人是从我的 Obsidian + Hugo 系列，开始了解原来 Obsidian 和 Hugo 还可以这么搭配的。
但是不少人反馈，根据 Hugo 博客写作最佳实践 和 Obsidian + Hugo 最佳配置推荐 这两篇文章操作起来感觉确实方便了，但是方便的不多。整个流程没有非常流畅。甚至感觉有些流程设计的过于繁琐。
不否认，确实是这种感觉，问题在我。
实际上这是我设计的一整套流程，但这两篇博客只讲了关键的一部分，还有一些细枝末节没有讲出来。
所以我临时决定再增加一篇文章说明，把整套流程讲清楚。担心表达能力欠佳，我还录了视频辅助大家理解。
中心思想 整个流程设计的中心思想就是：解决繁琐的操作流程，把操作自动化+高度集中，解放思想，精力都用在写作上。
管理面板 在 Obsidian 的诸多插件的加持下，最终实现所有管理功能集成在一个管理中心，效果如下：
上图中的内容共分为几部分：
 统计图，这里只根据发布情况做了发布占比统计，大家完全可以根据自己的需求设计更美观实用的统计图表 操作按钮+笔记：共集成了三个操作按钮，点击新建博客按钮可以根据模板自动创建一篇空白文章；点击发布博客按钮可以把博客内容自动推送到 github，从而触发 github action 自动部署流程；点击获取更新按钮可以从github上同步最新的仓库内容。 草稿箱：使用 dataview 插件，把草稿内容列举出来，归集为草稿箱，直接点击对应草稿便可以开始编辑内容 已发布：把所有已经发布的内容列举出来，方便查看  视频演示 以下视频演示了整个 新建 -&amp;gt; 写作 -&amp;gt; 发布 流程，一刀未剪 
技术细节 接下来说一下技术细节。说实话，这里其实并没有太多技术细节，只是一层窗户纸罢了，只要一捅破，大家瞬间就明白了，看到这里应该有很多人已经可以明白实现原理了。
基于 Hugo 博客写作最佳实践 这篇文章，我们可以通过 QuickAdd 插件实现各种自动化命令，在此基础上，只需要增加一个 Buttons 插件，便可以把命令通过点击按钮的方式进行调用。
Buttons 插件安装完成之后，在首页添加如下代码：
 新建博客按钮代码  发布博客按钮代码  获取更新按钮代码   总结 以上就是全部内容了，没有什么高深的技术内容，都是一些插件运用的技巧。 有了这个管理面板之后，你是不是可以把精力全部放在写作上了呢？</description>
    </item>
    
    <item>
      <title>如果我们想实现一个 WAF之 -- 什么是 WAF</title>
      <link>https://blog.zhangyingwei.com/posts/2024m1d25h13m45s53/</link>
      <pubDate>Thu, 25 Jan 2024 13:45:53 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2024m1d25h13m45s53/</guid>
      <description>如果我们想实现一个简易的 WAF，我们实际上需要干什么？我们需要先了解什么是 WAF。
🐭 什么是 WAF WAF 全称 Web Application Firewall，是一种工作在应用层（7 层）的防火墙，主要用于对应用层中的 HTTP 流量进行监测、过滤和阻止。主要适用于 Web 应用中存在的已知的安全漏洞，例如：SQL 注入、CSRF 跨站请求伪造攻击、XSS 跨站脚本攻击等。
其主要防护原理是基于规则匹配，通过预制的识别规则，对 HTTP 协议中提取出来的信息进行匹配，如果可以匹配，则该请求被认为是攻击行为。WAF 将会对其执行相关的操作（告警、阻断、记录日志）。
综上所诉，WAF 的基本原理如下：
那么回到问题，什么是 WAF 呢？
 WAF 是一个工作在应用层，主要针对 HTTP 流量进行解析、检测的装置；其检测功能主要基于规则引擎，通过预制规则，对流量中的相关信息进行匹配，能够针对流量中的 SQL 注入、CSRF、XSS 等 Web 攻击行为进行识别与防护，防护手段主要有告警、阻断、记录日志。
 🐮 WAF 通常部署在哪里 从形态上来讲， WAF 主要分为软件型 WAF 和硬件型 WAF
软件型 WAF 主要以嵌入的形式进行部署，一般部署在 Web 服务器中，常见的例如 nginx waf、apache waf、openresty waf 等。
硬件型 WAF 主要通过软件绑定硬件的方式，其部署方式多种多样，以下内容中的 WAF 默认指代硬件 WAF。
WAF 的部署模式通常有： 反向代理、透明代理、透明桥、流量镜像等方式。
反向代理 客户与 WAF 进行交互，WAF 将客户的请求直接转发至后端，后方的 Web Server 与 WAF 进行交互，不会直接暴漏给客户。</description>
    </item>
    
    <item>
      <title>防止 SQL 注入：WAF 就足够了吗？</title>
      <link>https://blog.zhangyingwei.com/posts/2024m1d15h10m42s57/</link>
      <pubDate>Tue, 16 Jan 2024 10:42:58 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2024m1d15h10m42s57/</guid>
      <description>在目前的网络攻防环境中，SQL 注入仍然是一种应用广泛、操作简单、且效果显著的攻击手段。防范 SQL 注入攻击，对于防止数据泄露、保护用户隐私和保护 Web 应用的完整性任然是至关重要的一项工作。
Web 应用程序防火墙（WAF）系统，通常被认为是防御 SQL 注入攻击的主要基础设施。但有 WAF 真的就足够了吗？答案当然是否定的。
接下来，首先解释一下 WAF 如何防止 SQL 注入的，然后再展示它可能在什么情况下无法提供足够的保护能力。
WAF 如何防御 SQL 注入 简单来说，WAF 在 SQL 注入类防护中，主要通过监控应用层协议在网络流量中的潜在恶意签名、字符序列来达到防护效果。通过监控和过滤 HTTP GET 和 POST 请求，并解析传入的 SQL 代码片段，WAF 可以识别已知的有害 SQL 语法，并且对相应的恶意的数据包流量进行告警与阻止。
虽然 WAF 可以提供针对 SQL 注入攻击的安全检测和防护，但其有效性取决于它的识别规则。
什么情况下 WAF 会失效 在许多情况下，WAF 可能无法防止 SQL 注入：
 未知的攻击模式和特征：WAF 擅长检测已知的攻击模式和特征，面对更复杂或未知的攻击方法则力有不逮。 封装技术：攻击者可以对载荷做针对性处理；使用嵌套编码，或者将恶意请求的部分放在 WAF 检查的字节之外；面对这种封装过后的载荷，WAF不具备识别能力。 配置错误：WAF的识别和防护功能，依赖防护规则的配置，如果规则配置错误，它可能无法提供足够防护能力来保护和抵御更复杂或不常见的 SQL 注入攻击。 更新和调整：随着 WEB 开发技术的更新迭代，有些更新可能会使之前的防护规则失效；如果 WAF 没有定期更新升级相应的规则，将无法提供相应的防护能力。 非网络流量数据：WAF 只能处理来自网络流量的问题，如果问题来自应用程序内部的代码或数据源而不经过网络力量，则 WAF 无法处理 0Day 漏洞：WAF 无法防止 0Day 漏洞利用 JSON 语法：WAF 可能无法识别 SQL 注入载荷中的恶意 JSON 语法内容，从而可以使用此类攻击者绕过 WAF 保护  示例  Claroty 研究人员能够通过在 SQL 注入攻击中使用 JSON 语法绕过 Amazon Web Services（AWS）内置的 WAF。通过将简单的 JSON 语法前置到 SQL 请求的开头，他们可以使用 SQLi 漏洞在云上泄露敏感信息。同样的 JSON in SQL 攻击也对 Cloudflare、F5、Imperva 和 Palo Alto Networks 的 WAF 有效 Reddit 用户对 WAF 测试了几个 SQL 注入负载，发现 WAF 基于某些关键字阻止了一些请求，同时仍然允许其他可疑查询。例如，/?</description>
    </item>
    
    <item>
      <title>盘点那些年我做过的东西</title>
      <link>https://blog.zhangyingwei.com/posts/2024m1d15h10m37s29/</link>
      <pubDate>Mon, 15 Jan 2024 10:37:29 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2024m1d15h10m37s29/</guid>
      <description>我是一个很容易焦虑的人，大部分焦虑都源自经济压力。
我也是一个很理想主义的人，始终妄想着能够做出一款为大家所认可的产品，随之产生睡后收入。
我还是一个很悲观的人，在做产品的过程中，随着不断的自我反思，会不断陷入：这个东西有人做了；这个东西不会有市场的；这个东西不是一个人能做出来的。等等类似的自我怀疑中。
这些年有不少想法，做了不少工作，但是都胎死腹中，分享出来供大家消遣。我的 Github 签名是 “废材程序员”，真是太贴切了。
treehole-jekyll (一个有点想法的博客系统) 一个包含完整前后端功能的博客系统，使用 Java 开发，采用 sqlite 作为数据库，兼容了 Jekyll 的主题。
部署在小水管云服务器中，后因为优化力度不够+Java对内存的优化确实不是很好，导致小水管只够跑一个博客服务。不能忍受资源浪费，遂放弃自建服务回到 Github Pages 的怀抱。省心省力省钱。
Solid (为博客开发的模板引擎) 在上诉博客系统开发过程中，为了兼容 Jekyll 模板引擎语法，开发的基于 Java 的模板引擎，可以嵌入到 Springboot 中作为视图渲染引擎进行使用。后一直闲置至今。 Hermes (基于 RSS 的文章聚合推荐平台) 有一段时间特别痴迷 RSS，而当时市面上的 RSS 阅读器并没有独角兽的出现，找来找去没找到合适的，所以就种下了 “我要开发一个的蛊”，后来来来回回做了好几个， hermes 算是整体完成度比较高的一个。具备完整的前端+后台+RSS爬虫+任务调度。
还做过一个叫 Miner 的应用，后来也不了了之了。
专注了吗小程序 前段时间逛论坛的时候，发现微信小程序个人认证的费用降到了 30 块，本着宁可不用不能没有的原则赶紧充值上车了。
又本着空着也是空着，总要放点什么的原则，做了这款专注了吗的小程序。主打任务专注管理。
AI 套壳工具 AI 突然就火了，套壳工具如雨后春笋般冒出来，做肯定要做一个的，但是由于聊天回应特别慢，接口延迟的问题一直没法解决，所以一直也没进行推广。想用的可以联系我在后台免费加套餐。花钱暂时就免了吧。
cockroach2 (开源 java 爬虫框架) 有一段时间，对爬虫特别痴迷，而且正好那段时间在研究 Java 的对象管理，索性整合一下做了一个爬虫框架。主打用尽可能少的配置、写出一个灵活、健壮的爬虫。当时在第一个版本出来的时候还许下豪言，要做真正的分布式爬虫，而不仅仅是队列+爬虫；要集成分布式任务、分布式事务等等，后续由于工作繁忙也渐渐的都放下了。目前任然是一个小巧、灵活、健壮、可观测的爬虫框架。 ultraman-rpc (一个练手的RPC项目) 单纯练手项目，实现了基于接口的 RPC 调用。 fas-cloud （faas 平台） 云，是一个很迷人的概念。曾经我也立志在云上创出一片天。但是最终还是没有完成。
整体项目完成了 50% 左右，做了 Function 函数管理功能、Function模板管理功能、Function 执行以及动态管理功能，很遗憾没有做完，</description>
    </item>
    
    <item>
      <title>专注了吗，一款因微信认证费降价而产生的产品</title>
      <link>https://blog.zhangyingwei.com/posts/2024m1d3h13m25s53/</link>
      <pubDate>Wed, 03 Jan 2024 13:25:54 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2024m1d3h13m25s53/</guid>
      <description>最近偶然在论坛看到有人说微信认证费用降价，由以前的 300 块降低至 30 块，于是赶紧去做了认证。
既然已经做了认证，那么名额空着视乎不太好，于是便产生了做一个产品出来挂着的念头。而说到产品，就不得不提研发人员三板斧，导航、记账和代办。
索性就在这里找个角度切入，从代办的角度切入，从另外的角度做了这款叫 《专注了吗》 的任务跟踪小程序。
目前小程序已经上架，主页是： https://miniapp.fascloud.org/
主要功能 小程序主要功能为记录任务的进展情况，例如：
 学生党记录每一科的学习进度以及时间花费情况 上班党记录每一个工作的具体进展 宝妈记录宝宝的吃饭情况，拉屎 💩 情况 等等&amp;hellip;  所有适用于分段完成的任务都可以用来记录。
界面 </description>
    </item>
    
    <item>
      <title>QuickDashboard 产品更新 [V0.0.9.0]</title>
      <link>https://blog.zhangyingwei.com/posts/2022m5d24h15m23s26/</link>
      <pubDate>Wed, 01 Jun 2022 15:23:27 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2022m5d24h15m23s26/</guid>
      <description>这个项目到目前为止没做过什么推广，只在 V 站和其他一两个常逛的论坛发了一下，因此也没有太多人知道。 Chrome 和 Edge 两个商店加起来大概有一百五十个左右的用户。所以很大程度还是属于一个自娱自乐的项目。
近期需要经常关注 B 站 几个账号的粉丝数量，因此设计并上线了一个监控看板的功能。
监控看板主要为了监控数字类的数据内容，比如上边提到的 B 站某个账号的粉丝等。
这个版本共包含了 4 个监控项。
 B 站某个账号的粉丝数量 B 站某个账号的视频数量 Github 账号的 Follower 数量 Github 某个仓库的 Star 数量  效果图如下：
感兴趣的可以在 ChromeStore 或者 Edge Store 进行更新试用。
有问题可以直接在评论区反馈</description>
    </item>
    
    <item>
      <title>QuickDashboard 产品介绍</title>
      <link>https://blog.zhangyingwei.com/posts/2022m5d16h20m22s20/</link>
      <pubDate>Mon, 16 May 2022 20:22:21 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2022m5d16h20m22s20/</guid>
      <description>我的新作品 QuickDashboard，是一款 Chrome 浏览器插件。得益于 Chromium 内核的成功，理论上只要是基于 Chromium 内核的浏览器都可以兼容。
   下载地址：      七牛云 下载   Chrome 商店 下载    QuickDashboard 是一款新标签页插件，所谓新标签页插件就是插件安装之后会接管 Chrome 浏览器新建标签页行为，取代默认的空白标签页，打开插件作为浏览器的新标签页。
这个插件，一共提供了四个大的功能项。
 以下所有说明均基于目前的最新版本 V0.8.0.0
 1. 时钟 时钟模块提供了翻页时钟和点阵时钟两种展示方式
翻页时钟 点阵时钟  时钟的颜色可以自定义，详细操作见设置说明
 2. 书签管理 书签管理功能主要基于 Chrome 的书签管理接口，作为 Chrome 书签的增强功能。在 Chrome 自身书签的基础上进行扩展。
 为书签增加了界面 扩展了标签功能，支持为每个书签增加标签，方便分类，每个书签最多可以设置 5 个标签 增加搜索功能，支持模糊搜索；可以通过书签名、书签目录名以及标签名进行搜索  3. 导航页 导航页是一个高频使用的功能， QuickDashboard 提供的导航页具备了目前市面上绝大多数导航页具备的功能：
 快捷搜索功能，提供搜索框，可以快速搜索 可以自定义添加导航网址 导航网址支持分类  在此基础上，还额外创新提供了根据设置进行差异化导航的功能。</description>
    </item>
    
    <item>
      <title>Obsidian &#43; Hugo 最佳配置推荐</title>
      <link>https://blog.zhangyingwei.com/posts/2022m4d12h13m13s22/</link>
      <pubDate>Tue, 12 Apr 2022 13:13:22 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2022m4d12h13m13s22/</guid>
      <description>静态博客的出现，革了后端的命，极大的简化了搭建环节。但是与此同时，在写作方式上，更加依赖第三方编辑器，能否找到一个合适的编辑器成了大多数人能否坚持使用下去的源动力。本文基于 Hugo 静态博客推荐个人认为最优的编辑器 Obsidian。
Obsidian 是一款非常优秀的双链笔记编辑器。其最主要亮点功能是通过双链构建知识网络。具有完备的编辑器、强大的命令工具以及众多优秀的插件。
关于 Obsidian 的相关配置方案可以参考上一篇文章《 Hugo 博客写作最佳实践 》，在文章中，介绍了如何通过 QuickAdd 插件快速创建一篇博文，以及如何快速编写发布文章，其中还包括如何进行静态资源同步上传图床以及外链回写的实现。
本文主要介绍在实现上文的工作流的基础上，一些写作最佳实践。
1.美观 写作是一个长期的行为，在写作过程中需要一直面对编辑器进行构思，编写，排版，调整。所以，一个符合个人审美的编辑器尤为重要。
Obsidian 编辑器本身作为一个颜值在线的编辑器，已经具备了很高的颜值起点。而且如果对官方主题不满意的话，可以在设置中的外观菜单项里打开主题管理功能，在主题社区中选择符合个人需求的主题进行替换。
除此之外，我们还可以通过自定义 CSS 代码片段对部分展示效果进行调整。这里提供修改编辑器字体的样例。
在外观选项中点击文件夹图标打开 CSS 代码片段目录
在打开的目录中新建文件  字体修改.css 并在文件中输入如下内容。
.view-content div.cm-line,.cm-string { font-family: &amp;#34;仿宋&amp;#34; !important; } .markdown-preview-section { font-family: &amp;#34;仿宋&amp;#34; !important; } 效果如下：
2.方便 基于当前的工作流程，在 Obsidian 中我们已经可以完成从创建到编写到发布所有工作。但是这还不够，既然使用了 Obsidian，我们虽然没办法使用其丰富的 markdown 语法。但是不耽误享受其丰富的插件系统带来的种种便利。
这里推荐另外两个插件 homepage 和 dataview
  homepage 允许 Obsidian 在打开之后显示默认笔记页面作为仪表面板 dataview 是 Obsidian 众多插件中，构建索引的王者。   通过 homepage ，可以设定一个页面作为 Obsidian 打开之后的默认主仪表面板。在上篇文章中，创建了 obs_scripts 目录用来存储创建文章的脚本。本文复用该目录，在其中创建一篇名叫 主面板 的笔记。</description>
    </item>
    
    <item>
      <title>Hugo 博客写作最佳实践</title>
      <link>https://blog.zhangyingwei.com/posts/2022m4d11h19m42s28/</link>
      <pubDate>Mon, 11 Apr 2022 19:42:28 +0800</pubDate>
      
      <guid>https://blog.zhangyingwei.com/posts/2022m4d11h19m42s28/</guid>
      <description>如今，如果你仅仅为了更好的分享或者记录东西，想做一个博客；静态博客几乎是最好的选择。不需要太多的技术含量，网上有大把的教程，不需要花钱买服务器，甚至不需要花钱买域名。
这篇文章是在使用 hugo 将博客搭建起来的基础上，摸索出来的一套写作流程。可有最大程度上简化除了写作之外的流程。
🏖️前提 这篇文章的前提是你已经通过 hugo 和 github 搭建起来一个可以访问的 Github Pages 主页。如果尚未完成这个步骤，建议通过其他教程先做到这一步。
🤣当前痛点 在当前的流程中，假如你需要新建一篇文章并发布，大体流程如下：
 打开命令行工具，切换到博客目录下，执行 hugo new posts/newarticle.md 创建一个新页面 构思编写文章，如果中途需要贴图片，需要先将图片拷贝到指定静态资源目录下或者上传到图床并复制外链到剪贴板，然后在文章中通过图片引入语法添加图片。 文章写完之后，再次打开命令行工具，切换到博客目录下，执行 hugo -D 编译静态网站文件。 通过 git 命令行或者图形话工具，将更新上传至 Github 仓库中。完成！  以上便是发布一篇文章的基础工作，其中最麻烦便是图片资源的管理以及来回切换工具操作。
☝️如何解决 1. 自动编译 首要解决的问题是如何才能不需要每次手动编译之后再上传。这也是最好解决的部分。我们可以搭配 Github Actions 使仓库在更新的时候自动编译部署。
 Github Actions 是 Github 提供的一套持续集成服务。
 操作流程：
 在仓库的根目录新建 .github/workfolws 目录 在 .gitub/workflows 目录中新建流程配置文件 main.yml 在 main.yml 中配置每当监听到仓库提交更新，就触发编译，并将编译后的静态网页部署在 gh-pages 分支。  文件目录如下：
配置内容如下：
name: blog deploy pipline on: push: tags: - &amp;#39;*&amp;#39; branches: [ main ] env: REGISTRY: ghcr.</description>
    </item>
    
  </channel>
</rss>
